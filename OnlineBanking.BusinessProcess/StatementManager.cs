//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace OnlineBanking.BusinessProcess
{
    using OnlineBanking.DAL;
    using OnlineBanking.DataModel;
    using System;
    using System.Collections.Generic;
    using System.Data.Entity;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    /// <summary>
    /// Manages statement transactions.
    /// </summary>
    public class StatementManager
    {
        /// <summary>
        /// Request an account statement for the given account and the given month.
        /// </summary>
        /// <param name="accountNumber">The account number to generate the statement for.</param>
        /// <param name="month">The month to generate the statement for.</param>
        /// <returns>The statement for the given account at the given month.</returns>
        public async virtual Task<Statement> RequestAccountStatement(string accountNumber, Double month, int customerID)
        {
            Crypto crypto = new Crypto();
            accountNumber = crypto.Encrypt(accountNumber);
            Statement statement = new Statement();
            try
            {
                Account account;
                using (var context = new BankContext())
                {
                    account = await (context.CheckingAccounts.Where(c => c.accountNumber == accountNumber && c.customerID == customerID).FirstOrDefaultAsync<Account>());
                    if (account == null)
                    {
                        account = await (context.SavingsAccounts.Where(s => s.accountNumber == accountNumber && s.customerID == customerID).FirstOrDefaultAsync<Account>());
                    }
                    if (account != null)
                    {           // no need to encrypt or decrypt, both values are encrypted
                        List<TransferTransaction> transferTransactions = (context.TransferTransactions.Where(t =>
                            (t.fromAccountNumber == accountNumber || t.toAccountNumber == accountNumber) && t.dateTime.Month == month).AsEnumerable<TransferTransaction>()).ToList();

                        if (transferTransactions != null)
                        {
                            account.Statement = transferTransactions;
                        }
                        statement.accountNumber = account.accountNumber;
                        statement.month = month;
                        statement.statementData = transferTransactions;

                        // StatementTransaction could be null and still be valid, i.e. no transactions.
                        context.StatementTransactions.Add(new StatementTransaction()
                        {
                            CustomerID = account.customerID,
                            status = "Success",
                            dateTime = DateTime.Now,
                            transactionType = Transaction.TransactionType.Statement
                        });
                    }
                    else
                    {
                        context.StatementTransactions.Add(new StatementTransaction()
                        {
                            CustomerID = account.customerID,
                            status = "Fail",
                            dateTime = DateTime.Now,
                            transactionType = Transaction.TransactionType.Statement
                        });
                    }
                    context.SaveChanges();
                }
                foreach (TransferTransaction transaction in statement.statementData)
                {
                    transaction.fromAccountNumber = crypto.Decrypt(transaction.fromAccountNumber);
                    transaction.toAccountNumber = crypto.Decrypt(transaction.toAccountNumber);
                }
                statement.accountNumber = crypto.Decrypt(statement.accountNumber);
            }
            catch (Exception)
            {
                throw new Exception("Error getting the account statement.");
            }
            return statement;
        }

    }
}

